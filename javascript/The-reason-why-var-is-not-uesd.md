JS에는 3가지의 변수를 정의하는 키워드 `var`, `let`, `const`가 존재합니다.
`let`, `const`는 CS6부터 추가가 되었는데, 이 키워드들이 어떤 이유에서 추가가 되었는지, `var`에 의해 생긴 문제점은 어떤 것들이 있는지 정리해 보도록 하겠습니다.

# 스코프(Scope)

위의 정리할 내용을 이해하기 위해선 `스코프`라는 개념을 이해해야합니다.
**스코프**는 한국말로 범위를 뜻하고, 우리는 `변수를 다룰 수 있는 범위`라고 이해할 수 있습니다.

프로그래밍 공부를 할때 전역변수, 지역변수라는 말을 들어보셨을겁니다. 이때 쓰이는 것과 같은 의미로 **전역범위(global)**, **지역스범위(local)**란 말로 쓰입니다.

지역범위는 해당지역에 대한 범위로 만약 지역범위에 변수를 선언했다면 지역 외에서 변수에 대한 접근은 불가합니다. 예를들어 함수 내에 선언된 변수라면 함수가 기능을 다하고 종료될 때 같이 삭제됩니다.
반대로 전역범위는 어떤 지역(local)에 해당되지 않고 어디에서든 접근 가능합니다.

이러한 범위에 선언된 변수를 전역변수, 지역변수라 말할 수 있습니다.

JS에서 `var`의 경우 "함수 스코프"이고, `let`, `const`은 "블록 스코프"입니다.

함수 스코프와 블록 스코프는 지역범위에 포함되는 개념입니다.

블록 스코프는 {}의 범위에서 사용할 수 있습니다.

# var의 특징

`var`의 문제점이라고 적을까 했지만, var 자체에 문제가 있는 것이 아니라고 생각이 들어서 특징이라고 하겠습니다. 지금 시점에서 굳이 말하자면 `var`를 사용하게 되면 맞이할 수 있는 문제들이겠네요.

현재 `var`가 거의 쓰이지 않고 추천되지도 않는 이유를 보겠습니다.

## 1. 재선언(?)

```js
var person = "Was born."

var person = "Born again!!"
```

출력 값은 `Born again!!`입니다.
위와 같이 선언된 변수이름을 다시 선언해도 실행됩니다.

`var`는 다시 선언해도 문제가 없습니다.

선언된 변수가 다시 선언될 수 있다는 것은, 이미 다른 곳에서 사용하고 있던 변수를 의도와 상관없이 대체할 수 있다는 말입니다.
재선언으로 인해서 갑자기 다른 곳에 버그가 생긴다면, 바로 이유를 찾기 힘들고 불편한 일입니다.

프로그래밍하는 개발자에게 문제가 되는 상황에 오류메세지를 표시해주는 것은 매우 중요하기 때문에, 여기서부터 추천되지 않는 이유를 알 수 있습니다.

## 2. 호이스팅

`호이스팅`이란 실행될 때 선언된 모든 것들을 코드의 상단으로 끌어올리는 것입니다. 

```js
console.log(myName);

var myName = "9d";
```

위 코드의 출력값은 `undefined`입니다.
호출된 이후에 선언했는데도 오류가 생기지 않고 값이 초기화된 이유는 호이스팅되며 `var` 타입의 변수에 `undefined`의 값이 할당되었기 때문입니다.

즉, `var`는 호이스팅 될시 **undefined**의 값을 할당받습니다.
하지만 `let`과 `const`는 **ReferenceError: myName is not defined**라는 오류를 받게됩니다.

## 3. 범위

처음에 설명한 범위에 대한 특징입니다.
위에서 `var`를 함수 스코프라고 말했습니다.
설명한 함수레벨, 블록레벨은 지역범위에 포함되는 단위입니다.

이해하기 쉽게 설명하자면 `지역범위이면서 함수범위에 포함되는 변수`입니다.

```js
var person = "Where is my house?";

function home() {
  var person = "It's my home.";
  console.log(person);
}

home();
```

어떤 값을 출력하는지 봤더니 `It's my home.`이 출력됩니다.
함수레벨의 범위이기 때문에 전역범위의 변수보다 함수안에 있는 값을 우선하기 때문입니다.

위의 코드만으로 보면 `let`, `const`와 다른 점은 없습니다.
다만 차이점은 **블록레벨**이란 것인데,

당장은 이것이 for문 같은 기능을 사용할 때 문제가 되지 않을 수 있으나, setTimeout()과 같은 함수들과 사용하면 문제가 생길 수 있습니다.

## 3-1 범위 - for문

위에서도 설명했지만 `var`의 경우 함수레벨의 범위를 가졌기 때문에 함수 이외에 다른 곳에선 예상하는 것과 다르게 작동할 수 있습니다.

```js
for(var i = 0; i<5; i++) {
  ...
}
```

위의 코드가 종료 된 뒤에 변수 i의 값은 5입니다.
즉, 종료된 뒤에도 변수의 값이 유지되어 있고 사용될 수 있습니다.

이는 블록레벨이 아닌 함수레벨이기 때문에 구문에서는 다르게 작동하기 때문입니다.

## 3-2 범위 - for문2

두번째 문제로 비동기와 함께 사용시에 문제가 있습니다.

```js
for (var i = 0; i < 5; i++) {
    setTimeout(() => {
      console.log(i + "실행");
    }, 1000);
}
```

```js
5실행
5실행
5실행
5실행
5실행
```

위의 코드를 보면 `5실행`이 5번 실행된 것을 볼 수 있습니다.

이또한 `var`가 함수레벨의 범위를 가지기 때문에 나타나는 문제점입니다.
for문에서 각 콜백함수를 호출할 때의 i값은 모두 달랐을 것이지만, 실행시점엔 i의 값은 5이기 때문에 위와 같이 같은 값이 5번 실행되고 있습니다.

`let`은 블록레벨의 범위를 가지고 있기 때문에 외부에서 접근할 수 없고, 블록 안에서 또한 외부로 노출될 수 없습니다. `let`의 값은 블록 안에서 고정되기 때문에 사용자의 의도에 가깝게 사용될 수 있습니다.

이 문제는 비동기와 논블록과 관련이 있기 때문에 개념의 이해가 필요합니다.

# 정리

`var`는 설명한 특징은 "JS가 굉장히 난해한 언어다."라는 말이 생긴 것에 상당부분 일조했다고 생각합니다.

현재는 위와 같은 문제들을 ES6부터 `let`, `const`등을 추가하면서 개선하였습니다. 하지만 왜 `var`가 쓰이지 않는지, 어떤 특징을 가지고 있는지는 인지하고 있어야 합니다.

자바스크립트는 브라우저에 동적인 움직임을 추가하기 위해 만들어졌고, 그 시작과 함께 현재까지 사용되고 있는 언어입니다.
ES6이전에 사용되었던 코드에 `var`가 사용되고 있기 때문에, 현재까지 더 나은 방법이 등장했음에도 지원을 종료하지 않는 것이라 생각합니다.

이후에 오래된 `var`를 만나도 당황하지 않길!